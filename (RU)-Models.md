### Необходимые материалы
- [Сущности](https://github.com/dimmpixeye/ecs/wiki/%28RU%29-Entities)
- [Акторы](https://github.com/dimmpixeye/ecs/wiki/%28RU%29-Actors)

***

### Что такое модель ?

Модель - это один из способов настройки сущности или актора из кода. По своему назначению напоминает схемы (blueprints).
> На заметку: в фреймворке нет жесткого требования к названию этого шаблона проектирования.

### Как создавать ?

* Создайте sealed partial class Model : ScriptableBuilds

```csharp
[CreateAssetMenu]
sealed partial class Model : ScriptableBuild
{

}
```
* Добавьте статик метод с названием описывающим вашу модель сущности.
```csharp
public static void Bunny(in ent entity)
{ 
  entity.Set(Tag.CanPoo);
  
  entity.Set<ComponentAI>();

  var cAbilityJump =  entity.Set<ComponentAbilityJump>();
  var cAbilityEat  =  entity.Set<ComponentAbilityEat>();

  cAbilityJump.distance = 10f;
  cAbilityEat.foodType  = "Carrot";	 
}
```
Логически блок кода модели можно разделить на несколько частей:
- Первыми идут тэги.
- Далее добавляются компоненты чья настройка не нужна.
- Далее идет список компонентов требующих настроек в рамках модели.
- После идет настройка объявленных компонентов
 
_в каком порядке что добавлять является вопросом стиля и вкуса.

#### Метод Set
В моделях у сущности *всегда* используется метод Set вместо Add. Модели добавляются чуть-чуть иначе. Все манипуляции с компонентами в фреймворке идут через отложенные действия. Например, при создании объекта с 10 компонентами через ADD мы вызовем 10 операций добавления. Но используя ```Set``` будет только одна. 

#### Метод Deploy
Когда мы используем ```Set``` нам нужен механизм который бы уведомил бы фреймворк что мы закончили настройку сущности.
Для этого существует метод ```Deploy();```

```csharp
 ent e = Entity.Create("Obj Bunny", true);
 e.Set<ComponentCute>();
 e.Deploy();
```
Модели и Акторы не требуют вызова в конце настройки Deploy так как это делает сам фреймворк. Решение спорное так как скрывает действие от программиста. 

### Как использовать?

#### Cпособ 1
Вернет нового актора и назначит ему новый игровой объект (gameobject). Объект будет получен из папки Resources по имени.
Настройки для актора будут взяты из ```Model.Bunny```
```csharp
Actor.Create("Obj Unit", Model.Bunny);
Actor.Create("Obj Sprite", Model.Bunny);
```

#### Cпособ 2
Вернет актора и назначит ему игровой объект найденный на сцене.  
Настройки для актора будут взяты из ```Model.Bunny```
```csharp
var obj = GameObject.Find("Hollow Soul");
Actor.CreateFor(obj, Model.Bunny);
```

#### Способ 3
Вернет cущность и и назначит ей новый игровой объект (gameobject). Объект будет получен из папки Resources по имени.
Настройки для актора будут взяты из ```Model.Bunny```
```csharp
Entity.Create("Obj Sprite", Model.Bunny);
```

### Зачем использовать ?
* Модели убирают настройку сущности из рабочей области проекта что ведет к повышению читаемости кода.
* Модели универсальны: одну и ту же модель можно применить на разных префабах. 
* Модели добавляют все компоненты одной операцией. _( справедливо и для акторов )_
* Модели не требуют наследований от класса Actor и размещения унаследованных компонентов на префабах.


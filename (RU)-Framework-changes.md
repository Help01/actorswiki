Здесь описаны изменения коснувшиеся фреймворка. Полезно в первую очередь для миграции существующих проектов.

### Новый namespace Pixeye.Framework
Весь фреймворк теперь находится в области имен Pixeye.Framework. Почему?
Для специализации. В своих проектах я пользуюсь областью имен Pixeye :) 

### Изменения коснувшиеся редактора
Добавлены drag листы для массивов и листов в инспекторе. Улучшен foldout group атрибут.
Сразу хочу предупредить, что драг листы написаны не мной, а взяты [отсюда](https://github.com/ChemiKhazi/UnityToolbag/tree/master/SortableArrayAttribute). Посчитал полезной фишкой для редактора. Если вы пользуетесь ODIN инспектором, то инспектор фреймворка будет отключен так что никаких проблем с совместимостью возникнуть не должно.

### Изменения коснувшиеся Starter скриптов
[![Starter gif](https://i.gyazo.com/5394a111b5f82cc800379feca2d3ab0f.gif)](https://gyazo.com/5394a111b5f82cc800379feca2d3ab0f)

Теперь ассеты сцен можно добавлять в билд лист прямо из стартера, так же сцену можно подгрузить в редакторе нажав на плюсик. 

### Шаблон компонентов
Чтобы избежать ручного добавления бойлерплейт кода при создании компонентов используйте шаблон компонента. 
- (ПКМ project->Actors Framework-> Generate Component)

[![Component Generator](https://i.gyazo.com/414ec932933a0de1fcb938ac75499c9e.gif)](https://gyazo.com/414ec932933a0de1fcb938ac75499c9e)

### Изменение наименований 

- Вместо ProcessingBase просто Processor
```csharp
public class ProcessorCollisions : Processor, ITick
	{
```
- Все классы фреймворка которые были со словом Processing теперь используют Processor
```csharp
ProcessorSignals.Send(); // ProcessingSignals
```

### Сущности
Вместо ```int``` для обозначения индекса сущности теперь используется структура ```ent```. 

Почему?
Использование ```int``` в качестве ключа было быстро и удобно, но так как во фреймворке очень много extension методов для удобной работы с сущностями ( вроде обращений к компонентам ) то выходило так, что например можно было попытаться обратиться к компоненту у длинны массива просто потому что он возвращает ```int```.  

```ent``` весит 5 байт ( против 4 байт ```int``` ) и состоит из int id отвечающий за сам ключ и byte age отвечающий за поколение сущности.

Зачем нужны поколения? 
Пример. 
Есть пушка с автонаведением и у нее была цель с индексом 10. Это корабль инопланетян имеющий серьезные намерения совершать непотребства с игроком и его союзниками. Он был уничтожен и индекс 10 освободился и ушел в пул свободных сущностей. Родилась робоальпака, верный союзник игрока. Она взяла индекс 10... и теперь пушка расстреливает робоальпаку. Просто потому что ее цель была с индексом 10 и пушка просто не знает, что десятка теперь друг. 

Поколения являются дополнительной проверкой на соответствие. Так, корабль инопланетян был индексом 10 с поколением 0.
При рождении альпаки бог из машины увидел, что когда-то подобная сущность существовала и присвоил ей поколение 1.

Так как ent является структурой, value-значением то у пушки осталась информация о _старой_ десятке. Пушка смотрит что индексы совпадают, а поколения - нет, а значит предыдущая цель однозначно была уничтожена и это уже что-то другое.

Поколения выражены одним байтом, а это значит что их может быть 256 на каждую сущность, после чего отчет начнется от нуля.

### Создание сущностей

Сущности конвертируемы в int значения.
```csharp
ent entity = 10; // так можно. Но за фасадом это выглядит как ent entity = new ent(10,0) где id=10, age=0
```
Однако это не приведет к регистрации сущности в фреймворке. Ниже примеры как надо.

```csharp
// создаем пустую сущность
ent entity = ent.Create();
```

```csharp
// создаем сущность и соединяем ее с префабом из Resources
var entity = ent.CreateFrom("obj player");
```

```csharp
// создаем сущность и соединяем ее с префабом из Resources
var prefab = Resources.Load("Prefabs/obj player") as GameObject;
// тоже самое только передаем префаб
var entity = ent.CreateFrom(prefab);
			 
```

 




